--- /usr/lib/python2.5/site-packages/TurboGears-1.1b1dev_r4679-py2.5.egg/turbogears/database_old.py	2008-06-05 22:35:04.000000000 +0200
+++ database.py	2008-06-06 12:22:05.000000000 +0200
@@ -6,6 +6,14 @@
 
 import cherrypy
 from cherrypy.filters.basefilter import BaseFilter
+import turbogears
+
+try:
+    import dejavu
+    import atexit
+    from threading import local as threading_local
+except ImportError:
+    dejavu = None
 
 try:
     import sqlalchemy, sqlalchemy.orm
@@ -20,6 +28,20 @@
 except ImportError:
     sqlobject = None
 
+# This key is non existant (turbogears.orm)
+# there could exist import issues with this approach
+# right now dejavu is the default for testing pourposes
+_orm = turbogears.config.get( "turbogears.orm", "dejavu" )
+if _orm == "sqlobject":
+    sqlalchemy = None
+    dejavu = None
+elif _orm == "sqlalchemy":
+    sqlobject = None
+    dejavu = None
+elif _orm == "dejavu":
+    sqlobject = None
+    sqlalchemy = None
+
 from peak.rules import abstract, when, NoApplicableMethods
 
 from turbogears import config
@@ -272,6 +294,120 @@
             del self.threadingLocal.old_conn
             self.threadingLocal.connection.cache.clear()
 
+# provide support for Dejavu
+elif dejavu:
+    _arena = None
+    _stores = dict()
+
+    READ_UNCOMMITTED = dejavu.storage.isolation.READ_UNCOMMITTED
+    READ_COMMITTED = dejavu.storage.isolation.READ_COMMITTED
+    REPEATABLE_READ = dejavu.storage.isolation.REPEATABLE_READ
+    SERIALIZABLE = dejavu.storage.isolation.SERIALIZABLE
+
+    def _arena_shutdown():
+        global _arena
+        if _arena:
+            log.info("Arena shutdown...")
+            _arena.shutdown()
+    atexit.register( _arena_shutdown )
+
+    class AutoConnectHub(object):
+        """Connects to the database once per thread. The AutoConnectHub also
+        provides convenient methods for managing transactions."""
+        uri = None
+        params = {}
+
+        def __init__(self, uri=None, supports_transactions=True):
+            if not uri:
+                uri = config.get("dejavu.dburi")
+            self.uri = uri
+            self.supports_transactions = supports_transactions
+            self.threadingLocal = threading_local()
+            hub_registry.add(self)
+
+        def getConnection(self):
+            """Returns the Dejavu SandBox"""
+            global _arena, _stores
+            uri_hash = ( self.uri, id( self.uri ) )[ isinstance( self.uri, dict ) ]
+            try:
+                return self.threadingLocal.boxes[ uri_hash ]
+            except ( AttributeError, KeyError ):
+                if not _arena:
+                    log.info("Arena startup...")
+                    _arena = dejavu.Arena()
+                if isinstance( self.uri, dict ):
+                    # Load a dictionary of dictionaries as the store configuration
+                    for key in self.uri:
+                        if not _stores.has_key( "store://" + key ):
+                            try:
+                                klass = self.uri[ key ][ "Class" ]
+                                del self.uri[ key ][ "Class" ]
+                                _arena.add_store( key, klass, self.uri[ key ] )
+                                _stores[ "store://" + key ] = True
+                                log.info("New store: %s" % key )
+                            except KeyError:
+                                log.error("Unknown class for store %s" % key )
+                else:
+                    # Load from a file, cache the file
+                    if not _stores.has_key( "file://" + self.uri ):
+                        _arena.load( self.uri )
+                        _stores[ "file://" + self.uri ] = True
+                        log.info("New store: %s" % self.uri )
+                try:
+                    self.threadingLocal.boxes
+                except AttributeError:
+                    self.threadingLocal.boxes = {}
+                box = self.begin( _arena.new_sandbox() )
+                self.threadingLocal.boxes[ uri_hash ] = box
+            return box
+
+        def reset(self):
+            """Used for testing purposes. This drops all of the connections
+            that are being held."""
+            self.threadingLocal = threading_local()
+
+        def begin(self, conn=None):
+            """Starts a transaction."""
+            if not self.supports_transactions:
+                return conn
+            if not conn:
+                conn = self.getConnection()
+            conn.start( isolation=READ_COMMITTED )
+            return conn
+
+        def commit(self):
+            """Commits the current transaction."""
+            if not self.supports_transactions:
+                return
+            try:
+                conn = self.threadingLocal.boxes[ ( self.uri, id( self.uri ) )[ isinstance( self.uri, dict ) ] ]
+            except  ( AttributeError, KeyError ):
+                return
+            conn.commit()
+
+        def rollback(self):
+            """Rolls back the current transaction."""
+            if not self.supports_transactions:
+                return
+            try:
+                conn = self.threadingLocal.boxes[ ( self.uri, id( self.uri ) )[ isinstance( self.uri, dict ) ] ]
+            except  ( AttributeError, KeyError ):
+                return
+            conn.rollback()
+
+        def end(self):
+            """Ends the transaction, returning to a standard connection."""
+            if not self.supports_transactions:
+                return
+            try:
+                conn = self.threadingLocal.boxes[ ( self.uri, id( self.uri ) )[ isinstance( self.uri, dict ) ] ]
+            except  ( AttributeError, KeyError ):
+                return
+            conn.flush_all()
+
+# The PackageHub class is common for SQLObject and Dejavu
+if dejavu or sqlobject:
+
     class PackageHub(object):
         """Transparently proxies to an AutoConnectHub for the URI
         that is appropriate for this package. A package URI is
@@ -307,16 +443,20 @@
                 dburi = config.get("sqlobject.dburi", None)
             if not dburi:
                 raise KeyError, "No database configuration found!"
-            if dburi.startswith("notrans_"):
+            if isinstance( dburi, dict ) and dburi.has_key("__notrans__"):
+                trans = False
+            elif not isinstance( dburi, dict ) and dburi.startswith("notrans_"):
                 dburi = dburi[8:]
                 trans = False
             else:
                 trans = True
-            hub = _hubs.get(dburi, None)
+            uri_hash = ( dburi, id( dburi ) )[ isinstance( dburi, dict ) ]
+            hub = _hubs.get( uri_hash, None )
             if not hub:
                 hub = AutoConnectHub(dburi, supports_transactions=trans)
-                _hubs[dburi] = hub
+                _hubs[uri_hash] = hub
             self.hub = hub
+
 else:
     class AutoConnectHub(object):
         pass
@@ -512,6 +652,10 @@
         so_joins(sqlclass.__base__, joins)
     return joins
 
+def dj_to_dict(unit):
+    """Converts a Dejavu unit to a dictionary based on columns"""
+    return dict( zip( unit.properties, [ getattr( unit, property ) for property in unit.properties ] ) )
+
 class EndTransactionsFilter(BaseFilter):
     def on_end_resource(self):
         if _use_sa():
@@ -522,4 +666,4 @@
            "get_engine", "get_metadata", "bind_metadata", "create_session",
            "PackageHub", "AutoConnectHub", "set_db_uri",
            "commit_all", "rollback_all", "end_all", "so_to_dict",
-           "so_columns", "so_joins", "EndTransactionsFilter"]
+           "so_columns", "so_joins", "dj_to_dict", "EndTransactionsFilter"]
